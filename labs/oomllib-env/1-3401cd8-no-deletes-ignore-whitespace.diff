diff --git a/.gitignore b/.gitignore
index 2e90e788fa..357cb66f0f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,71 +1 @@
-node_modules/
-built/*
-tests/cases/rwc/*
-tests/cases/test262/*
-tests/cases/perf/*
-!tests/cases/webharness/compilerToString.js
-test-args.txt
-~*.docx
-\#*\#
-.\#*
-tests/baselines/local/*
-tests/baselines/local.old/*
-tests/services/baselines/local/*
-tests/baselines/prototyping/local/*
-tests/baselines/rwc/*
-tests/baselines/test262/*
-tests/baselines/reference/projectOutput/*
-tests/baselines/local/projectOutput/*
-tests/baselines/reference/testresults.tap
-tests/services/baselines/prototyping/local/*
-tests/services/browser/typescriptServices.js
-src/harness/*.js
-src/compiler/diagnosticInformationMap.generated.ts
-src/compiler/diagnosticMessages.generated.json
-rwc-report.html
-*.swp
-build.json
-*.actual
-tests/webTestServer.js
-tests/webTestServer.js.map
-tests/webhost/*.d.ts
-tests/webhost/webtsc.js
-tests/cases/**/*.js
-tests/cases/**/*.js.map
-*.config
-scripts/debug.bat
-scripts/run.bat
-scripts/word2md.js
-scripts/buildProtocol.js
-scripts/ior.js
-scripts/authors.js
-scripts/configurePrerelease.js
-scripts/processDiagnosticMessages.d.ts
-scripts/processDiagnosticMessages.js
-scripts/importDefinitelyTypedTests/importDefinitelyTypedTests.js
-scripts/generateLocalizedDiagnosticMessages.js
-scripts/*.js.map
-scripts/typings/
-coverage/
-internal/
-**/.DS_Store
-.settings
-**/.vs
-**/.vscode
-!**/.vscode/tasks.json
-!tests/cases/projects/projectOption/**/node_modules
-!tests/cases/projects/NodeModulesSearch/**/*
-!tests/baselines/reference/project/nodeModules*/**/*
-.idea
-yarn.lock
-yarn-error.log
-.parallelperf.*
-tests/cases/user/*/package-lock.json
-tests/cases/user/*/node_modules/
-tests/cases/user/*/**/*.js
-tests/cases/user/*/**/*.js.map
-tests/cases/user/*/**/*.d.ts
-!tests/cases/user/zone.js/
-!tests/cases/user/bignumber.js/
-!tests/cases/user/discord.js/
-tests/baselines/reference/dt
\ No newline at end of file
+/oomlc-core-env-gen-*.jar
diff --git a/compile.sh b/compile.sh
new file mode 100755
index 0000000000..c2cbc27def
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,12 @@
+#!/usr/bin/env bash
+
+set -e
+
+pushd "$(dirname "$0")"
+
+mvn clean compile assembly:single
+cp target/oomlc-core-env-gen-*.jar .
+
+popd
+
+exit 0
diff --git a/lib/lib.dom.d.ts b/dec/dom.generated.d.ts
similarity index 99%
rename from lib/lib.dom.d.ts
rename to dec/dom.generated.d.ts
index 362c69de42..1c75c73804 100644
--- a/lib/lib.dom.d.ts
+++ b/dec/dom.generated.d.ts
@@ -1,23 +1,3 @@
-/*! *****************************************************************************
-Copyright (c) Microsoft Corporation. All rights reserved. 
-Licensed under the Apache License, Version 2.0 (the "License"); you may not use
-this file except in compliance with the License. You may obtain a copy of the
-License at http://www.apache.org/licenses/LICENSE-2.0  
- 
-THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
-MERCHANTABLITY OR NON-INFRINGEMENT. 
- 
-See the Apache Version 2.0 License for specific language governing permissions
-and limitations under the License.
-***************************************************************************** */
-
-
-
-/// <reference no-default-lib="true"/>
-
-
 /////////////////////////////
 /// DOM APIs
 /////////////////////////////
@@ -3992,7 +3972,7 @@ interface Document extends Node, GlobalEventHandlers, ParentNode, DocumentEvent
     /**
      * Retrieves a value that indicates the current state of the object.
      */
-    readonly readyState: string;
+    readonly readyState: DocumentReadyState;
     /**
      * Gets the URL of the location that referred the user to the current page.
      */
@@ -4251,6 +4231,7 @@ interface Document extends Node, GlobalEventHandlers, ParentNode, DocumentEvent
      */
     queryCommandValue(commandId: string): string;
     releaseEvents(): void;
+    updateSettings(): void;
     webkitCancelFullScreen(): void;
     webkitExitFullscreen(): void;
     /**
@@ -6275,7 +6256,7 @@ interface HTMLInputElement extends HTMLElement {
     /**
      * Returns a FileList object on a file type input object.
      */
-    readonly files: FileList | null;
+    files: FileList | null;
     /**
      * Retrieves a reference to the form that the object is embedded in.
      */
@@ -12877,6 +12858,7 @@ interface SourceBuffer extends EventTarget {
     readonly audioTracks: AudioTrackList;
     readonly buffered: TimeRanges;
     mode: AppendMode;
+    readonly textTracks: TextTrackList;
     timestampOffset: number;
     readonly updating: boolean;
     readonly videoTracks: VideoTrackList;
@@ -14817,6 +14799,8 @@ declare var WheelEvent: {
 
 interface WindowEventMap extends GlobalEventHandlersEventMap {
     "abort": UIEvent;
+    "afterprint": Event;
+    "beforeprint": Event;
     "beforeunload": BeforeUnloadEvent;
     "blur": FocusEvent;
     "canplay": Event;
@@ -14948,6 +14932,8 @@ interface Window extends EventTarget, WindowTimers, WindowSessionStorage, Window
     readonly navigator: Navigator;
     offscreenBuffering: string | boolean;
     onabort: ((this: Window, ev: UIEvent) => any) | null;
+    onafterprint: ((this: Window, ev: Event) => any) | null;
+    onbeforeprint: ((this: Window, ev: Event) => any) | null;
     onbeforeunload: ((this: Window, ev: BeforeUnloadEvent) => any) | null;
     onblur: ((this: Window, ev: FocusEvent) => any) | null;
     oncanplay: ((this: Window, ev: Event) => any) | null;
@@ -15758,6 +15744,8 @@ declare const name: never;
 declare var navigator: Navigator;
 declare var offscreenBuffering: string | boolean;
 declare var onabort: ((this: Window, ev: UIEvent) => any) | null;
+declare var onafterprint: ((this: Window, ev: Event) => any) | null;
+declare var onbeforeprint: ((this: Window, ev: Event) => any) | null;
 declare var onbeforeunload: ((this: Window, ev: BeforeUnloadEvent) => any) | null;
 declare var onblur: ((this: Window, ev: FocusEvent) => any) | null;
 declare var oncanplay: ((this: Window, ev: Event) => any) | null;
@@ -16002,6 +15990,7 @@ type ChannelCountMode = "max" | "clamped-max" | "explicit";
 type ChannelInterpretation = "speakers" | "discrete";
 type DisplayCaptureSurfaceType = "monitor" | "window" | "application" | "browser";
 type DistanceModelType = "linear" | "inverse" | "exponential";
+type DocumentReadyState = "loading" | "interactive" | "complete";
 type EndOfStreamError = "network" | "decode";
 type ExpandGranularity = "character" | "word" | "sentence" | "textedit";
 type GamepadHand = "" | "left" | "right";
diff --git a/src/lib/dom.iterable.d.ts b/dec/dom.iterable.d.ts
similarity index 96%
rename from src/lib/dom.iterable.d.ts
rename to dec/dom.iterable.d.ts
index 6ca728444f..e470b5408d 100644
diff --git a/src/lib/es2015.collection.d.ts b/dec/es2015.collection.d.ts
similarity index 96%
rename from src/lib/es2015.collection.d.ts
rename to dec/es2015.collection.d.ts
index 06a3473076..65b6759c8c 100644
diff --git a/src/lib/es2015.core.d.ts b/dec/es2015.core.d.ts
similarity index 97%
rename from src/lib/es2015.core.d.ts
rename to dec/es2015.core.d.ts
index 68be040c29..c1303de8ae 100644
diff --git a/src/lib/es2015.d.ts b/dec/es2015.d.ts
similarity index 90%
rename from src/lib/es2015.d.ts
rename to dec/es2015.d.ts
index 36f22af624..a04d6392e3 100644
diff --git a/src/lib/es2015.generator.d.ts b/dec/es2015.generator.d.ts
similarity index 96%
rename from src/lib/es2015.generator.d.ts
rename to dec/es2015.generator.d.ts
index 92bb8dca86..319510c10a 100644
diff --git a/src/lib/es2015.iterable.d.ts b/dec/es2015.iterable.d.ts
similarity index 96%
rename from src/lib/es2015.iterable.d.ts
rename to dec/es2015.iterable.d.ts
index ccb7df6be6..12c07681fc 100644
diff --git a/src/lib/es2015.promise.d.ts b/dec/es2015.promise.d.ts
similarity index 97%
rename from src/lib/es2015.promise.d.ts
rename to dec/es2015.promise.d.ts
index 14602c0b5e..6bb4f26caa 100644
diff --git a/src/lib/es2015.proxy.d.ts b/dec/es2015.proxy.d.ts
similarity index 98%
rename from src/lib/es2015.proxy.d.ts
rename to dec/es2015.proxy.d.ts
index 50671aedcc..552bf33c47 100644
diff --git a/src/lib/es2015.reflect.d.ts b/dec/es2015.reflect.d.ts
similarity index 98%
rename from src/lib/es2015.reflect.d.ts
rename to dec/es2015.reflect.d.ts
index 61a864b633..1119bc2ad8 100644
diff --git a/src/lib/es2015.symbol.d.ts b/dec/es2015.symbol.d.ts
similarity index 92%
rename from src/lib/es2015.symbol.d.ts
rename to dec/es2015.symbol.d.ts
index 8444ef2461..9224dde93d 100644
diff --git a/src/lib/es2015.symbol.wellknown.d.ts b/dec/es2015.symbol.wellknown.d.ts
similarity index 96%
rename from src/lib/es2015.symbol.wellknown.d.ts
rename to dec/es2015.symbol.wellknown.d.ts
index 681b6e8edf..1d86465d51 100644
diff --git a/src/lib/es2016.array.include.d.ts b/dec/es2016.array.include.d.ts
similarity index 97%
rename from src/lib/es2016.array.include.d.ts
rename to dec/es2016.array.include.d.ts
index 1012c18407..0353d38493 100644
diff --git a/dec/es2016.d.ts b/dec/es2016.d.ts
new file mode 100644
index 0000000000..6a09c6c79b
--- /dev/null
+++ b/dec/es2016.d.ts
@@ -0,0 +1,2 @@
+/// <reference path="lib.es2015.d.ts" />
+/// <reference path="lib.es2016.array.include.d.ts" />
\ No newline at end of file
diff --git a/src/lib/es2017.d.ts b/dec/es2017.d.ts
similarity index 97%
rename from src/lib/es2017.d.ts
rename to dec/es2017.d.ts
index 87aa273140..cc1b5dc528 100644
diff --git a/src/lib/es2017.intl.d.ts b/dec/es2017.intl.d.ts
similarity index 97%
rename from src/lib/es2017.intl.d.ts
rename to dec/es2017.intl.d.ts
index b878353019..6701f85852 100644
diff --git a/src/lib/es2017.object.d.ts b/dec/es2017.object.d.ts
similarity index 98%
rename from src/lib/es2017.object.d.ts
rename to dec/es2017.object.d.ts
index 1790ce7689..cda34193c5 100644
diff --git a/src/lib/es2017.sharedmemory.d.ts b/dec/es2017.sharedmemory.d.ts
similarity index 97%
rename from src/lib/es2017.sharedmemory.d.ts
rename to dec/es2017.sharedmemory.d.ts
index b9a9b0f7e1..4b171a8f85 100644
diff --git a/src/lib/es2017.string.d.ts b/dec/es2017.string.d.ts
similarity index 98%
rename from src/lib/es2017.string.d.ts
rename to dec/es2017.string.d.ts
index 80139e3712..07767feb05 100644
diff --git a/src/lib/es2017.typedarrays.d.ts b/dec/es2017.typedarrays.d.ts
similarity index 94%
rename from src/lib/es2017.typedarrays.d.ts
rename to dec/es2017.typedarrays.d.ts
index a0b64135a3..d4c8fdcb59 100644
diff --git a/src/lib/es2018.d.ts b/dec/es2018.d.ts
similarity index 64%
rename from src/lib/es2018.d.ts
rename to dec/es2018.d.ts
index 1abddc6fe2..e15e6b5c8c 100644
diff --git a/src/lib/es2018.promise.d.ts b/dec/es2018.promise.d.ts
similarity index 97%
rename from src/lib/es2018.promise.d.ts
rename to dec/es2018.promise.d.ts
index 28f903870b..343874a99a 100644
diff --git a/src/lib/es2018.regexp.d.ts b/dec/es2018.regexp.d.ts
similarity index 93%
rename from src/lib/es2018.regexp.d.ts
rename to dec/es2018.regexp.d.ts
index 85e1bc909b..fd2b48a8f3 100644
diff --git a/lib/lib.es5.d.ts b/dec/es5.d.ts
similarity index 99%
rename from lib/lib.es5.d.ts
rename to dec/es5.d.ts
index 6c26ab4b63..4b15e0f6e6 100644
--- a/lib/lib.es5.d.ts
+++ b/dec/es5.d.ts
@@ -1,23 +1,3 @@
-/*! *****************************************************************************
-Copyright (c) Microsoft Corporation. All rights reserved. 
-Licensed under the Apache License, Version 2.0 (the "License"); you may not use
-this file except in compliance with the License. You may obtain a copy of the
-License at http://www.apache.org/licenses/LICENSE-2.0  
- 
-THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
-MERCHANTABLITY OR NON-INFRINGEMENT. 
- 
-See the Apache Version 2.0 License for specific language governing permissions
-and limitations under the License.
-***************************************************************************** */
-
-
-
-/// <reference no-default-lib="true"/>
-
-
 /////////////////////////////
 /// ECMAScript APIs
 /////////////////////////////
@@ -792,8 +772,7 @@ interface Date {
 
 interface DateConstructor {
     new(): Date;
-    new(value: number): Date;
-    new(value: string): Date;
+    new(value: number | string): Date;
     new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;
     (): string;
     readonly prototype: Date;
diff --git a/src/lib/esnext.array.d.ts b/dec/esnext.array.d.ts
similarity index 97%
rename from src/lib/esnext.array.d.ts
rename to dec/esnext.array.d.ts
index ddba47bada..9777890a3f 100644
diff --git a/src/lib/esnext.asynciterable.d.ts b/dec/esnext.asynciterable.d.ts
similarity index 96%
rename from src/lib/esnext.asynciterable.d.ts
rename to dec/esnext.asynciterable.d.ts
index 8379ba5ba6..d17189ab4d 100644
diff --git a/src/lib/esnext.d.ts b/dec/esnext.d.ts
similarity index 97%
rename from src/lib/esnext.d.ts
rename to dec/esnext.d.ts
index 831d241cc3..fea35a4d0f 100644
diff --git a/src/lib/webworker.generated.d.ts b/dec/webworker.generated.d.ts
similarity index 99%
rename from src/lib/webworker.generated.d.ts
rename to dec/webworker.generated.d.ts
index b83072a969..abdfd73b4f 100644
diff --git a/src/lib/webworker.importscripts.d.ts b/dec/webworker.importscripts.d.ts
similarity index 96%
rename from src/lib/webworker.importscripts.d.ts
rename to dec/webworker.importscripts.d.ts
index 1c4c4f4e95..c3cedebd93 100644
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Main.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Main.java
new file mode 100644
index 0000000000..a9a638f5fc
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Main.java
@@ -0,0 +1,84 @@
+package org.ooml.oomlc.core.env.gen;
+
+import com.google.gson.Gson;
+import org.ooml.oomlc.core.env.gen.Parse.Exception.UnexpectedEndOfCodeException;
+import org.ooml.oomlc.core.env.gen.Parse.Lexing.Code;
+import org.ooml.oomlc.core.env.gen.Parse.Lexing.Lexer;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement.DeclarationStatement;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement.FunctionStatement;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement.InterfaceStatement;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement.Statement;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement.VariableStatement;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+
+public class Main {
+  private static final Map<TokenType, Function<Tokens, Statement>> PARSERS = _createParsersMap();
+
+  private static Map<TokenType, Function<Tokens, Statement>> _createParsersMap () {
+    Map<TokenType, Function<Tokens, Statement>> map = new HashMap<>();
+
+    map.put(TokenType.T_KEYWORD_CONST, VariableStatement::parseVariableStatement);
+    map.put(TokenType.T_KEYWORD_VAR, VariableStatement::parseVariableStatement);
+    map.put(TokenType.T_KEYWORD_FUNCTION, FunctionStatement::parseFunctionStatement);
+    map.put(TokenType.T_KEYWORD_DECLARE, DeclarationStatement::parseDeclarationStatement);
+    map.put(TokenType.T_KEYWORD_INTERFACE, InterfaceStatement::parseInterfaceStatement);
+
+    return map;
+  }
+
+  private static List<Statement> parseFile (String filePath) throws FileNotFoundException {
+    File file = new File(filePath);
+
+    FileInputStream sourceFile = new FileInputStream(file);
+    Code code = new Code(sourceFile);
+
+    Lexer lexer = new Lexer(code);
+    Tokens tokens = new Tokens(lexer);
+
+    List<Statement> statements = new ArrayList<>();
+
+    while (true) {
+      TokenType nextTokenType;
+      try {
+        nextTokenType = tokens.peekType();
+      } catch (UnexpectedEndOfCodeException ueoce) {
+        break;
+      }
+
+      Statement statement;
+
+      if (!PARSERS.containsKey(nextTokenType)) {
+        throw tokens.constructMalformedSyntaxException("Unknown statement");
+      }
+
+      statement = PARSERS.get(nextTokenType).apply(tokens);
+
+      tokens.skipIfNext(TokenType.T_SEMICOLON);
+
+      statements.add(statement);
+    }
+
+    return statements;
+  }
+
+  public static void main (String[] args) throws FileNotFoundException {
+    if (args.length != 1) {
+      throw new IllegalArgumentException("Malformed arguments");
+    }
+
+    List<Statement> statements = parseFile(args[0]);
+
+    Gson gson = new Gson();
+    System.out.println(gson.toJson(statements));
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/InternalStateError.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/InternalStateError.java
new file mode 100644
index 0000000000..215e27c87a
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/InternalStateError.java
@@ -0,0 +1,7 @@
+package org.ooml.oomlc.core.env.gen.Parse.Exception;
+
+public class InternalStateError extends Error {
+  public InternalStateError (String message) {
+    super(String.format("\n==============================================\nPLEASE REPORT THIS ERROR:\n\n%s\n\nThis is an internal error that should not have happened. Please report this error, along with its stack trace.", message));
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/MalformedSyntaxException.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/MalformedSyntaxException.java
new file mode 100644
index 0000000000..8ade1f302e
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/MalformedSyntaxException.java
@@ -0,0 +1,9 @@
+package org.ooml.oomlc.core.env.gen.Parse.Exception;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class MalformedSyntaxException extends SyntaxException {
+  public MalformedSyntaxException (String message, Position position) {
+    super(message, position);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/RequiredSyntaxNotFoundException.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/RequiredSyntaxNotFoundException.java
new file mode 100644
index 0000000000..1826d86662
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/RequiredSyntaxNotFoundException.java
@@ -0,0 +1,9 @@
+package org.ooml.oomlc.core.env.gen.Parse.Exception;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class RequiredSyntaxNotFoundException extends MalformedSyntaxException {
+  public RequiredSyntaxNotFoundException (String message, Position position) {
+    super(message, position);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/SyntaxException.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/SyntaxException.java
new file mode 100644
index 0000000000..58440a0c3c
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/SyntaxException.java
@@ -0,0 +1,24 @@
+package org.ooml.oomlc.core.env.gen.Parse.Exception;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public abstract class SyntaxException extends RuntimeException {
+  private final Position position;
+
+  public SyntaxException (String message) {
+    this(message, null);
+  }
+
+  public SyntaxException (String message, Position position) {
+    super(message);
+    this.position = position;
+  }
+
+  @Override
+  public String toString () {
+    if (position == null) {
+      return getMessage();
+    }
+    return String.format("%s [Line %d, Character %d]", getMessage(), position.getLine(), position.getColumn());
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/UnexpectedEndOfCodeException.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/UnexpectedEndOfCodeException.java
new file mode 100644
index 0000000000..12112aa26c
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Exception/UnexpectedEndOfCodeException.java
@@ -0,0 +1,7 @@
+package org.ooml.oomlc.core.env.gen.Parse.Exception;
+
+public class UnexpectedEndOfCodeException extends SyntaxException {
+  public UnexpectedEndOfCodeException () {
+    super("Unexpected end of code");
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/AcceptableChars.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/AcceptableChars.java
new file mode 100644
index 0000000000..1ab51e7562
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/AcceptableChars.java
@@ -0,0 +1,22 @@
+package org.ooml.oomlc.core.env.gen.Parse.Lexing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Acceptable;
+
+public class AcceptableChars extends Acceptable<Character> {
+  public AcceptableChars (String chars) {
+    super(toCharacterArray(chars));
+  }
+
+  public AcceptableChars (Character... chars) {
+    super(chars);
+  }
+
+  private static Character[] toCharacterArray (String chars) {
+    char[] charArray = chars.toCharArray();
+    Character[] characterArray = new Character[charArray.length];
+    for (int i = 0; i < charArray.length; i++) {
+      characterArray[i] = charArray[i];
+    }
+    return characterArray;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Code.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Code.java
new file mode 100644
index 0000000000..a7d00b8dd5
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Code.java
@@ -0,0 +1,239 @@
+package org.ooml.oomlc.core.env.gen.Parse.Lexing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Exception.MalformedSyntaxException;
+import org.ooml.oomlc.core.env.gen.Parse.Exception.UnexpectedEndOfCodeException;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Matchable;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.NoSuchElementException;
+
+public class Code implements Matchable<Character> {
+
+  private static final int MAX_HISTORICAL_BUFFER_SIZE = 1024;
+
+  private final BufferedReader inputStream;
+  /*
+   *
+   *          CONSUMED | UPCOMING
+   *   <lastReadChars> | <returnBuffer> <inputStream>
+   *
+   */
+  private final Deque<Character> returnBuffer = new ArrayDeque<>();
+  // Keep a maximum of MAX_HISTORICAL_BUFFER_SIZE last characters
+  // (i.e. can only call `backUp` sequentially at most 10 times)
+  private final Deque<Character> lastReadChars = new ArrayDeque<>(MAX_HISTORICAL_BUFFER_SIZE);
+  private int currentLineNo = 1;
+  private int currentColNo = 0;
+
+  public Code (InputStream inputStream) {
+    this.inputStream = new BufferedReader(new InputStreamReader(inputStream));
+  }
+
+  private char readChar () {
+    while (lastReadChars.size() > MAX_HISTORICAL_BUFFER_SIZE) {
+      lastReadChars.removeFirst();
+    }
+    char nextChar;
+    try {
+      nextChar = returnBuffer.removeFirst();
+    } catch (NoSuchElementException nsee) {
+      int nextCharAsInt;
+      try {
+        nextCharAsInt = inputStream.read();
+      } catch (IOException e) {
+        throw new UnexpectedEndOfCodeException();
+      }
+      if (nextCharAsInt == -1) {
+        throw new UnexpectedEndOfCodeException();
+      }
+      nextChar = (char) nextCharAsInt;
+    }
+    lastReadChars.addLast(nextChar);
+    switch (nextChar) {
+    case '\n':
+      if (lastReadChars.peekLast() == '\r') {
+        break;
+      }
+    case '\r':
+      currentLineNo++;
+      currentColNo = 0;
+      break;
+
+    default:
+      currentColNo++;
+    }
+    return nextChar;
+  }
+
+  public Position getCurrentPosition () {
+    return new Position(currentLineNo, currentColNo);
+  }
+
+  public void backUp () {
+    char ret = lastReadChars.removeLast();
+    switch (ret) {
+    case '\r':
+      if (returnBuffer.peekFirst() == '\n') {
+        break;
+      }
+    case '\n':
+      currentLineNo--;
+      currentColNo = -1;
+      break;
+
+    default:
+      currentColNo--;
+    }
+    returnBuffer.addFirst(ret);
+  }
+
+  public String acceptOptional (char c) {
+    char next = accept();
+    if (c != next) {
+      backUp();
+      return "";
+    }
+    return "" + next;
+  }
+
+  public String acceptOptional (AcceptableChars chars) {
+    char next = accept();
+    if (!chars.has(next)) {
+      backUp();
+      return "";
+    }
+    return "" + next;
+  }
+
+  public String acceptGreedy (AcceptableChars chars) {
+    StringBuilder res = new StringBuilder();
+    while (true) {
+      char next = accept();
+      if (!chars.has(next)) {
+        backUp();
+        break;
+      }
+      res.append(next);
+    }
+    return res.toString();
+  }
+
+  public String acceptUntil (char c) {
+    StringBuilder res = new StringBuilder();
+    while (true) {
+      char next = accept();
+      if (c == next) {
+        backUp();
+        break;
+      }
+      res.append(next);
+    }
+    return res.toString();
+  }
+
+  public String acceptUntil (AcceptableChars chars) {
+    StringBuilder res = new StringBuilder();
+    while (true) {
+      char next = accept();
+      if (chars.has(next)) {
+        backUp();
+        break;
+      }
+      res.append(next);
+    }
+    return res.toString();
+  }
+
+  public void skipGreedyBeforeEnd (AcceptableChars chars) {
+    while (true) {
+      char next = accept();
+      if (!chars.has(next)) {
+        backUp();
+        break;
+      }
+    }
+  }
+
+  public void skipUntil (char c) {
+    while (true) {
+      char next = accept();
+      if (c == next) {
+        backUp();
+        break;
+      }
+    }
+  }
+
+  public void skipUntil (AcceptableChars c) {
+    while (true) {
+      char next = accept();
+      if (c.has(next)) {
+        backUp();
+        break;
+      }
+    }
+  }
+
+  public char accept () {
+    return readChar();
+  }
+
+  public void skip () {
+    readChar();
+  }
+
+  public boolean skipIfNext (char c) {
+    char nextChar = readChar();
+    if (nextChar == c) {
+      return true;
+    } else {
+      backUp();
+      return false;
+    }
+  }
+
+  public char peek () {
+    char nextChar = readChar();
+    backUp();
+    return nextChar;
+  }
+
+  public char peek (int offset) {
+    if (offset < 1) {
+      throw new IllegalArgumentException("Invalid offset");
+    }
+
+    char nextChar = 0;
+    for (int i = 0; i < offset; i++) {
+      nextChar = readChar();
+    }
+    for (int i = 0; i < offset; i++) {
+      backUp();
+    }
+
+    return nextChar;
+  }
+
+  public MalformedSyntaxException constructMalformedSyntaxException (String message) {
+    Position pos = getCurrentPosition();
+
+    return new MalformedSyntaxException(message, pos);
+  }
+
+  @Override
+  public Character matcherConsume () {
+    return accept();
+  }
+
+  @Override
+  public void matcherReverse () {
+    backUp();
+  }
+
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Lexer.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Lexer.java
new file mode 100644
index 0000000000..6b0fb08399
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/Lexer.java
@@ -0,0 +1,166 @@
+package org.ooml.oomlc.core.env.gen.Parse.Lexing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Exception.InternalStateError;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Token;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.*;
+
+public class Lexer {
+  private static final AcceptableChars LINE_TERMINATOR = new AcceptableChars('\r', '\n');
+  private static final AcceptableChars WHITESPACE = new AcceptableChars('\r', '\n', '\t', ' ');
+
+  private static final AcceptableChars IDENTIFIER_STARTER = new AcceptableChars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$");
+  private static final AcceptableChars IDENTIFIER = new AcceptableChars("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789");
+
+  private static final Map<String, TokenType> SPECIAL_IDENTIFIER = _createSpecialIdentifierMap();
+  private static final OperatorTreeNode OPERATOR_TREE_ROOT_NODE = _createOperatorTreeRootNode();
+
+  private final Code code;
+
+  public Lexer (Code code) {
+    this.code = code;
+  }
+
+  private static OperatorTreeNode _createOperatorTreeRootNode () {
+    Map<String, TokenType> sequences = new HashMap<>();
+
+    sequences.put("...", T_ELLIPSIS);
+    sequences.put("(", T_LEFT_PARENTHESIS);
+    sequences.put(")", T_RIGHT_PARENTHESIS);
+    sequences.put("?(", T_QUESTION_AND_LEFT_PARENTHESIS);
+    sequences.put("[", T_LEFT_SQUARE_BRACKET);
+    sequences.put("]", T_RIGHT_SQUARE_BRACKET);
+    sequences.put("<", T_LEFT_CHEVRON);
+    sequences.put(">", T_RIGHT_CHEVRON);
+    sequences.put("{", T_LEFT_BRACE);
+    sequences.put("}", T_RIGHT_BRACE);
+
+    sequences.put(".", T_DOT);
+    sequences.put(":", T_COLON);
+    sequences.put("?:", T_QUESTION_AND_COLON);
+    sequences.put("?.", T_QUESTION_AND_DOT);
+    sequences.put("=>", T_EQUALS_AND_RIGHT_CHEVRON);
+    sequences.put("=", T_EQUALS);
+
+    sequences.put("|", T_PIPE);
+
+    sequences.put(",", T_COMMA);
+    sequences.put(";", T_SEMICOLON);
+
+    OperatorTreeNode rootNode = new OperatorTreeNode();
+
+    for (Map.Entry<String, TokenType> operator : sequences.entrySet()) {
+      rootNode.addSequence(operator
+        .getKey()
+        .toCharArray(), 0, operator.getValue());
+    }
+
+    return rootNode;
+  }
+
+  private static Map<String, TokenType> _createSpecialIdentifierMap () {
+    Map<String, TokenType> map = new HashMap<>();
+
+    map.put("const", T_KEYWORD_CONST);
+    map.put("declare", T_KEYWORD_DECLARE);
+    map.put("extends", T_KEYWORD_EXTENDS);
+    map.put("function", T_KEYWORD_FUNCTION);
+    map.put("interface", T_KEYWORD_INTERFACE);
+    map.put("keyof", T_KEYWORD_KEYOF);
+    map.put("new", T_KEYWORD_NEW);
+    map.put("readonly", T_KEYWORD_READONLY);
+    map.put("type", T_KEYWORD_TYPE);
+    map.put("var", T_KEYWORD_VAR);
+
+    return map;
+  }
+
+  private Token constructToken (TokenType type) {
+    return new Token(type, code.getCurrentPosition());
+  }
+
+  private Token constructToken (TokenType type, String value) {
+    return new Token(type, value, code.getCurrentPosition());
+  }
+
+  public Token lex () {
+    char nextChar = code.peek();
+
+    Token t;
+
+    if (nextChar == '/') {
+      if (code.peek(2) == '*') {
+        lexMLComment();
+      } else {
+        lexSLComment();
+      }
+      t = null;
+
+    } else if (OPERATOR_TREE_ROOT_NODE.hasChild(nextChar)) {
+      TokenType tokenType = OPERATOR_TREE_ROOT_NODE.match(code);
+      if (tokenType == null) {
+        throw code.constructMalformedSyntaxException("Invalid syntax");
+      }
+      t = constructToken(tokenType);
+
+    } else if (nextChar == '"') {
+      t = lexLiteralString();
+
+    } else if (IDENTIFIER_STARTER.has(nextChar)) {
+      t = lexIdentifier();
+
+    } else if (WHITESPACE.has(nextChar)) {
+      code.skipGreedyBeforeEnd(WHITESPACE);
+      t = null;
+
+    } else {
+      throw code.constructMalformedSyntaxException("Unknown syntax");
+    }
+
+    return t;
+  }
+
+  // This is called when starting literal (at char '"')
+  private Token lexLiteralString () {
+    code.skip();
+    String value = code.acceptUntil('"');
+    return constructToken(T_LITERAL_STRING, value);
+  }
+
+  // Called when next char is in IDENTIFIER_STARTER
+  private Token lexIdentifier () {
+    String value = code.acceptGreedy(IDENTIFIER);
+
+    if (SPECIAL_IDENTIFIER.containsKey(value)) {
+      TokenType specialIdentifierType = SPECIAL_IDENTIFIER.get(value);
+      return constructToken(specialIdentifierType);
+
+    } else {
+      return constructToken(T_IDENTIFIER, value);
+    }
+  }
+
+  // Called when next char is '/'
+  private void lexSLComment () {
+    code.skip();
+    code.skipUntil(LINE_TERMINATOR);
+    code.skip();
+  }
+
+  // Called when next char is '/*'
+  private void lexMLComment () {
+    code.skip();
+    code.skip();
+    while (true) {
+      code.skipUntil('*');
+      code.skip();
+      if (code.skipIfNext('/')) {
+        break;
+      }
+    }
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/OperatorTreeNode.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/OperatorTreeNode.java
new file mode 100755
index 0000000000..5e051ec5fa
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Lexing/OperatorTreeNode.java
@@ -0,0 +1,15 @@
+package org.ooml.oomlc.core.env.gen.Parse.Lexing;
+
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.MatcherTreeNode;
+
+public class OperatorTreeNode extends MatcherTreeNode<Character, TokenType> {
+  public void addSequence (char[] raw_sequence, int start, TokenType result) {
+    Character[] sequence = new Character[raw_sequence.length];
+    for (int i = 0; i < sequence.length; i++) {
+      sequence[i] = raw_sequence[i];
+    }
+    super.addSequence(sequence, start, result);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/AcceptableTokenTypes.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/AcceptableTokenTypes.java
new file mode 100644
index 0000000000..eca3246085
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/AcceptableTokenTypes.java
@@ -0,0 +1,13 @@
+package org.ooml.oomlc.core.env.gen.Parse.Parsing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Acceptable;
+
+public class AcceptableTokenTypes extends Acceptable<TokenType> {
+  public AcceptableTokenTypes (TokenType... tokenTypes) {
+    super(tokenTypes);
+  }
+
+  public boolean has (Token t) {
+    return has(t.getType());
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Token.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Token.java
new file mode 100644
index 0000000000..295fe11ec1
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Token.java
@@ -0,0 +1,34 @@
+package org.ooml.oomlc.core.env.gen.Parse.Parsing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class Token {
+  private final TokenType type;
+  private final String value;
+  // Position refers to the end of the token
+  private final Position position;
+
+  public Token (TokenType type, Position position) {
+    this.type = type;
+    this.value = null;
+    this.position = position;
+  }
+
+  public Token (TokenType type, String value, Position position) {
+    this.type = type;
+    this.value = value;
+    this.position = position;
+  }
+
+  public TokenType getType () {
+    return type;
+  }
+
+  public String getValue () {
+    return value;
+  }
+
+  public Position getPosition () {
+    return position;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/TokenType.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/TokenType.java
new file mode 100644
index 0000000000..c532dc3423
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/TokenType.java
@@ -0,0 +1,40 @@
+package org.ooml.oomlc.core.env.gen.Parse.Parsing;
+
+public enum TokenType {
+
+  T_COLON,
+  T_COMMA,
+  T_DOT,
+  T_ELLIPSIS,
+  T_EQUALS,
+  T_EQUALS_AND_RIGHT_CHEVRON,
+  T_LEFT_BRACE,
+  T_LEFT_CHEVRON,
+  T_LEFT_PARENTHESIS,
+  T_LEFT_SQUARE_BRACKET,
+  T_PIPE,
+  T_QUESTION_AND_COLON,
+  T_QUESTION_AND_DOT,
+  T_QUESTION_AND_LEFT_PARENTHESIS,
+  T_RIGHT_BRACE,
+  T_RIGHT_CHEVRON,
+  T_RIGHT_PARENTHESIS,
+  T_RIGHT_SQUARE_BRACKET,
+  T_SEMICOLON,
+
+  T_KEYWORD_CONST,
+  T_KEYWORD_DECLARE,
+  T_KEYWORD_EXTENDS,
+  T_KEYWORD_FUNCTION,
+  T_KEYWORD_INTERFACE,
+  T_KEYWORD_KEYOF,
+  T_KEYWORD_NEW,
+  T_KEYWORD_READONLY,
+  T_KEYWORD_TYPE,
+  T_KEYWORD_VAR,
+
+  T_LITERAL_STRING,
+
+  T_IDENTIFIER,
+
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Tokens.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Tokens.java
new file mode 100644
index 0000000000..fb4ca78dcd
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Parsing/Tokens.java
@@ -0,0 +1,173 @@
+package org.ooml.oomlc.core.env.gen.Parse.Parsing;
+
+import org.ooml.oomlc.core.env.gen.Parse.Exception.MalformedSyntaxException;
+import org.ooml.oomlc.core.env.gen.Parse.Exception.RequiredSyntaxNotFoundException;
+import org.ooml.oomlc.core.env.gen.Parse.Lexing.Lexer;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Matchable;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+public class Tokens implements Matchable<TokenType>, Iterable<Token> {
+
+  private final Lexer lexer;
+  private final List<Token> tokens = new ArrayList<>();
+  private int lastAcceptedPos = -1;
+
+  public Tokens (Lexer lexer) {
+    this.lexer = lexer;
+  }
+
+  private Token yieldNextToken () {
+    if (lastAcceptedPos < tokens.size() - 1) {
+      lastAcceptedPos++;
+      return tokens.get(lastAcceptedPos);
+    }
+    Token token;
+    while ((token = lexer.lex()) == null) {}
+    tokens.add(token);
+    lastAcceptedPos++;
+    return token;
+  }
+
+  public int getState () {
+    return lastAcceptedPos;
+  }
+
+  public void setState (int lastAcceptedPos) {
+    if (lastAcceptedPos < 0 || lastAcceptedPos >= tokens.size()) {
+      throw new IllegalArgumentException("Invalid state");
+    }
+    this.lastAcceptedPos = lastAcceptedPos;
+  }
+
+  public void backUp () {
+    lastAcceptedPos--;
+  }
+
+  private Position getPosition () {
+    if (lastAcceptedPos < 0) {
+      return new Position(1, 1);
+    } else {
+      return tokens
+        .get(lastAcceptedPos)
+        .getPosition();
+    }
+  }
+
+  public MalformedSyntaxException constructMalformedSyntaxException (String message) {
+    return new MalformedSyntaxException(message, getPosition());
+  }
+
+  public RequiredSyntaxNotFoundException constructRequiredSyntaxNotFoundException (String message) {
+    return new RequiredSyntaxNotFoundException(message, getPosition());
+  }
+
+  public Token require (TokenType type) {
+    Token t = yieldNextToken();
+    if (t.getType() != type) {
+      String message = String.format("Required %s, got %s", type, t.getType());
+      throw constructRequiredSyntaxNotFoundException(message);
+    }
+    return t;
+  }
+
+  public Token require (AcceptableTokenTypes types) {
+    Token t = yieldNextToken();
+    if (!types.has(t.getType())) {
+      String message = String.format("Unexpected %s", t.getType());
+      throw constructRequiredSyntaxNotFoundException(message);
+    }
+    return t;
+  }
+
+  public Token require (Set<TokenType> types) {
+    Token t = yieldNextToken();
+    if (!types.contains(t.getType())) {
+      String message = String.format("Unexpected %s", t.getType());
+      throw constructRequiredSyntaxNotFoundException(message);
+    }
+    return t;
+  }
+
+  public Token peek () {
+    Token t = yieldNextToken();
+    backUp();
+    return t;
+  }
+
+  public TokenType peekType () {
+    return peek().getType();
+  }
+
+  public TokenType peekType (int offset) {
+    return peek(offset).getType();
+  }
+
+  public Token peek (int offset) {
+    if (offset < 1) {
+      throw new IllegalArgumentException("Invalid offset");
+    }
+
+    Token t = null;
+    for (int i = 0; i < offset; i++) {
+      t = yieldNextToken();
+    }
+    for (int i = 0; i < offset; i++) {
+      backUp();
+    }
+    return t;
+  }
+
+  public Token accept () {
+    return yieldNextToken();
+  }
+
+  public Token acceptOptional (TokenType type) {
+    Token t = accept();
+    if (t.getType() != type) {
+      backUp();
+      return null;
+    }
+    return t;
+  }
+
+  public Token acceptOptional (AcceptableTokenTypes types) {
+    Token t = accept();
+    if (!types.has(t.getType())) {
+      backUp();
+      return null;
+    }
+    return t;
+  }
+
+  public void skip () {
+    yieldNextToken();
+  }
+
+  public boolean skipIfNext (TokenType type) {
+    return acceptOptional(type) != null;
+  }
+
+  public boolean skipIfNext (AcceptableTokenTypes types) {
+    return acceptOptional(types) != null;
+  }
+
+  @Override
+  public TokenType matcherConsume () {
+    return accept().getType();
+  }
+
+  @Override
+  public void matcherReverse () {
+    backUp();
+  }
+
+  @Override
+  public Iterator<Token> iterator () {
+    return tokens.iterator();
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Callable.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Callable.java
new file mode 100644
index 0000000000..188075cd7f
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Callable.java
@@ -0,0 +1,36 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type;
+
+import java.util.List;
+
+public class Callable {
+  private final boolean optional;
+  private final List<Parameter> parameters;
+  private final Type returnType;
+
+  private Callable (boolean optional, List<Parameter> parameters, Type returnType) {
+    this.optional = optional;
+    this.parameters = parameters;
+    this.returnType = returnType;
+  }
+
+  public static Callable parseCallable (Tokens tokens, TokenType returnTypeDelimiter, boolean canBeOptional) {
+    boolean optional = canBeOptional && tokens.skipIfNext(TokenType.T_QUESTION_AND_LEFT_PARENTHESIS);
+    if (!optional) {
+      tokens.require(TokenType.T_LEFT_PARENTHESIS);
+    }
+
+    List<Parameter> parameters = Parameter.parseParametersList(tokens);
+
+    tokens.require(TokenType.T_RIGHT_PARENTHESIS);
+
+    tokens.require(returnTypeDelimiter);
+
+    Type returnType = Type.parseType(tokens);
+
+    return new Callable(optional, parameters, returnType);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Identifier.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Identifier.java
new file mode 100755
index 0000000000..09ea041572
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Identifier.java
@@ -0,0 +1,52 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Token;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class Identifier {
+  private final String name;
+  private final Position position;
+
+  public Identifier (Position position, String name) {
+    this.position = position;
+    this.name = name;
+  }
+
+  public static Identifier requireIdentifier (Tokens tokens) {
+    Token value = tokens.require(TokenType.T_IDENTIFIER);
+    return new Identifier(value.getPosition(), value.getValue());
+  }
+
+  public static Identifier acceptIdentifier (Tokens tokens) {
+    Token token = tokens.acceptOptional(TokenType.T_IDENTIFIER);
+    if (token == null) {
+      return null;
+    }
+    return new Identifier(token.getPosition(), token.getValue());
+  }
+
+  public String getName () {
+    return name;
+  }
+
+  @Override
+  public String toString () {
+    return getName();
+  }
+
+  @Override
+  public int hashCode () {
+    return getName().hashCode();
+  }
+
+  @Override
+  public boolean equals (Object o) {
+    return o instanceof Identifier && getName().equals(((Identifier) o).getName());
+  }
+
+  public Position getPosition () {
+    return position;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/Interface.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/Interface.java
new file mode 100644
index 0000000000..ff97b477fe
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/Interface.java
@@ -0,0 +1,101 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.*;
+
+public class Interface {
+  private final Position position;
+  private final Identifier name;
+  private final List<Identifier> parents;
+  private final List<InterfaceCallSignature> callSignatures;
+  private final List<InterfaceIndexSignature> indexSignatures;
+  private final List<InterfaceConstructor> constructors;
+  private final List<InterfaceProperty> properties;
+  private final List<InterfaceMethod> methods;
+
+  private Interface (Position position, Identifier name, List<Identifier> parents, List<InterfaceCallSignature> callSignatures, List<InterfaceIndexSignature> indexSignatures, List<InterfaceConstructor> constructors, List<InterfaceProperty> properties, List<InterfaceMethod> methods) {
+    this.position = position;
+    this.name = name;
+    this.parents = parents;
+    this.callSignatures = callSignatures;
+    this.indexSignatures = indexSignatures;
+    this.constructors = constructors;
+    this.properties = properties;
+    this.methods = methods;
+  }
+
+  public static Interface parseInterface (Tokens tokens) {
+    Position position = tokens
+      .require(T_KEYWORD_INTERFACE)
+      .getPosition();
+
+    Identifier name = Identifier.requireIdentifier(tokens);
+
+    List<Identifier> parents = new ArrayList<>();
+
+    if (tokens.skipIfNext(T_KEYWORD_EXTENDS)) {
+      do {
+        parents.add(Identifier.requireIdentifier(tokens));
+      } while (tokens.skipIfNext(T_COMMA));
+    }
+
+    tokens.require(T_LEFT_BRACE);
+
+    List<InterfaceCallSignature> callSignatures = new ArrayList<>();
+    List<InterfaceIndexSignature> indexSignatures = new ArrayList<>();
+    List<InterfaceConstructor> constructors = new ArrayList<>();
+    List<InterfaceProperty> properties = new ArrayList<>();
+    List<InterfaceMethod> methods = new ArrayList<>();
+
+    TokenType nextTokenType;
+    while ((nextTokenType = tokens.peekType()) != T_RIGHT_BRACE) {
+      switch (nextTokenType) {
+      case T_KEYWORD_READONLY:
+        properties.add(InterfaceProperty.parseProperty(tokens));
+        break;
+
+      case T_IDENTIFIER:
+      case T_LITERAL_STRING:
+        if (tokens.peekType(2) == T_LEFT_PARENTHESIS ||
+            tokens.peekType(2) == T_QUESTION_AND_LEFT_PARENTHESIS) {
+          methods.add(InterfaceMethod.parseMethod(tokens));
+        } else {
+          properties.add(InterfaceProperty.parseProperty(tokens));
+        }
+        break;
+
+      case T_KEYWORD_NEW:
+        constructors.add(InterfaceConstructor.parseConstructor(tokens));
+        break;
+
+      case T_LEFT_PARENTHESIS:
+        callSignatures.add(InterfaceCallSignature.parseCallSignature(tokens));
+        break;
+
+      case T_LEFT_SQUARE_BRACKET:
+        indexSignatures.add(InterfaceIndexSignature.parseIndexSignature(tokens));
+        break;
+
+      default:
+        throw tokens.constructMalformedSyntaxException("Expected an interface body unit, got " + nextTokenType);
+      }
+
+      tokens.require(T_SEMICOLON);
+    }
+
+    tokens.require(T_RIGHT_BRACE);
+
+    return new Interface(position, name, parents, callSignatures, indexSignatures, constructors, properties, methods);
+  }
+
+  public Position getPosition () {
+    return position;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceCallSignature.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceCallSignature.java
new file mode 100644
index 0000000000..92528d40a7
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceCallSignature.java
@@ -0,0 +1,19 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Callable;
+
+public class InterfaceCallSignature {
+  private final Callable callable;
+
+  public InterfaceCallSignature (Callable callable) {
+    this.callable = callable;
+  }
+
+  public static InterfaceCallSignature parseCallSignature (Tokens tokens) {
+    Callable callable = Callable.parseCallable(tokens, TokenType.T_COLON, false);
+
+    return new InterfaceCallSignature(callable);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceConstructor.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceConstructor.java
new file mode 100644
index 0000000000..a22cc62d9e
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceConstructor.java
@@ -0,0 +1,23 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Callable;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.T_COLON;
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.T_KEYWORD_NEW;
+
+public class InterfaceConstructor {
+  private final Callable callable;
+
+  private InterfaceConstructor (Callable callable) {
+    this.callable = callable;
+  }
+
+  public static InterfaceConstructor parseConstructor (Tokens tokens) {
+    tokens.require(T_KEYWORD_NEW);
+
+    Callable callable = Callable.parseCallable(tokens, T_COLON, false);
+
+    return new InterfaceConstructor(callable);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceIndexSignature.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceIndexSignature.java
new file mode 100644
index 0000000000..7b55750c4f
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceIndexSignature.java
@@ -0,0 +1,36 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type;
+
+public class InterfaceIndexSignature {
+  private final Identifier name;
+  private final Type type;
+  private final Type returnType;
+
+  public InterfaceIndexSignature (Identifier name, Type type, Type returnType) {
+    this.name = name;
+    this.type = type;
+    this.returnType = returnType;
+  }
+
+  public static InterfaceIndexSignature parseIndexSignature (Tokens tokens) {
+    tokens.require(TokenType.T_LEFT_SQUARE_BRACKET);
+
+    Identifier name = Identifier.requireIdentifier(tokens);
+
+    tokens.require(TokenType.T_COLON);
+
+    Type type = Type.parseType(tokens);
+
+    tokens.require(TokenType.T_RIGHT_SQUARE_BRACKET);
+
+    tokens.require(TokenType.T_COLON);
+
+    Type returnType = Type.parseType(tokens);
+
+    return new InterfaceIndexSignature(name, type, returnType);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceMethod.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceMethod.java
new file mode 100644
index 0000000000..ee64449c89
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceMethod.java
@@ -0,0 +1,25 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Callable;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.T_COLON;
+
+public class InterfaceMethod {
+  private final Identifier name;
+  private final Callable callable;
+
+  private InterfaceMethod (Identifier name, Callable callable) {
+    this.name = name;
+    this.callable = callable;
+  }
+
+  public static InterfaceMethod parseMethod (Tokens tokens) {
+    Identifier name = Identifier.requireIdentifier(tokens);
+
+    Callable callable = Callable.parseCallable(tokens, T_COLON, true);
+
+    return new InterfaceMethod(name, callable);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceProperty.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceProperty.java
new file mode 100644
index 0000000000..7934033ec7
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Interface/InterfaceProperty.java
@@ -0,0 +1,50 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Token;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type;
+
+public class InterfaceProperty {
+  private final Identifier name;
+  private final Type type;
+  private final boolean isReadOnly;
+  private final boolean isOptional;
+
+  private InterfaceProperty (Identifier name, Type type, boolean isReadOnly, boolean isOptional) {
+    this.name = name;
+    this.type = type;
+    this.isReadOnly = isReadOnly;
+    this.isOptional = isOptional;
+  }
+
+  public static InterfaceProperty parseProperty (Tokens tokens) {
+    boolean isReadOnly = tokens.skipIfNext(TokenType.T_KEYWORD_READONLY);
+
+    Identifier name;
+
+    switch (tokens.peekType()) {
+    case T_IDENTIFIER:
+      name = Identifier.requireIdentifier(tokens);
+      break;
+
+    case T_LITERAL_STRING:
+      Token strtok = tokens.accept();
+      name = new Identifier(strtok.getPosition(), strtok.getValue());
+      break;
+
+    default:
+      throw tokens.constructRequiredSyntaxNotFoundException("Expected interface property name");
+    }
+
+    boolean isOptional = tokens.skipIfNext(TokenType.T_QUESTION_AND_COLON);
+    if (!isOptional) {
+      tokens.require(TokenType.T_COLON);
+    }
+
+    Type type = Type.parseType(tokens);
+
+    return new InterfaceProperty(name, type, isReadOnly, isOptional);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Parameter.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Parameter.java
new file mode 100644
index 0000000000..2cc7342d60
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Parameter.java
@@ -0,0 +1,62 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType.*;
+
+public class Parameter {
+  private final Identifier name;
+  private final Type type;
+  private final boolean optional;
+  private final boolean variableLength;
+  private final String defaultValue; // Can be null
+
+  private Parameter (Identifier name, Type type, boolean optional, boolean variableLength, String defaultValue) {
+    this.name = name;
+    this.type = type;
+    this.optional = optional;
+    this.variableLength = variableLength;
+    this.defaultValue = defaultValue;
+  }
+
+  private static Parameter parseParameter (Tokens tokens) {
+    boolean variableLength = tokens.skipIfNext(T_ELLIPSIS);
+    Identifier name = Identifier.requireIdentifier(tokens);
+
+    boolean optional = tokens.skipIfNext(T_QUESTION_AND_COLON);
+    if (!optional) {
+      tokens.require(T_COLON);
+    }
+
+    Type type = Type.parseType(tokens);
+
+    String defaultValue = null;
+    if (tokens.skipIfNext(T_EQUALS)) {
+      defaultValue = tokens.require(T_LITERAL_STRING).getValue();
+    }
+
+    return new Parameter(name, type, optional, variableLength, defaultValue);
+  }
+
+  public static List<Parameter> parseParametersList (Tokens tokens) {
+    List<Parameter> parameters = new ArrayList<>();
+
+    // Don't consume parenthesis as opening may be "?("
+
+    do {
+      // Allow parameters to end with comma
+      // No arguments is valid
+      if (tokens.peekType() == T_RIGHT_PARENTHESIS) {
+        break;
+      }
+
+      parameters.add(parseParameter(tokens));
+    } while (tokens.skipIfNext(T_COMMA));
+
+    return parameters;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarableStatement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarableStatement.java
new file mode 100644
index 0000000000..bd328afe33
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarableStatement.java
@@ -0,0 +1,19 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+
+public interface DeclarableStatement {
+  static DeclarableStatement parseDeclarableStatement(Tokens tokens) {
+    switch (tokens.peekType()) {
+    case T_KEYWORD_FUNCTION:
+      return FunctionStatement.parseFunctionStatement(tokens);
+
+    case T_KEYWORD_CONST:
+    case T_KEYWORD_VAR:
+      return VariableStatement.parseVariableStatement(tokens);
+
+    default:
+      throw tokens.constructRequiredSyntaxNotFoundException("Expected declarable statement");
+    }
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarationStatement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarationStatement.java
new file mode 100644
index 0000000000..e86ccca598
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/DeclarationStatement.java
@@ -0,0 +1,21 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class DeclarationStatement extends Statement {
+  private final DeclarableStatement declarable;
+
+  private DeclarationStatement (Position position, DeclarableStatement declarable) {
+    super(position);
+    this.declarable = declarable;
+  }
+
+  public static DeclarationStatement parseDeclarationStatement(Tokens tokens) {
+    Position position = tokens.require(TokenType.T_KEYWORD_DECLARE).getPosition();
+    DeclarableStatement declarableStatement = DeclarableStatement.parseDeclarableStatement(tokens);
+
+    return new DeclarationStatement(position, declarableStatement);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/FunctionStatement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/FunctionStatement.java
new file mode 100644
index 0000000000..1b85c18cbe
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/FunctionStatement.java
@@ -0,0 +1,28 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Callable;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class FunctionStatement extends Statement implements DeclarableStatement {
+  private final Identifier name;
+  private final Callable callable;
+
+  private FunctionStatement (Position position, Identifier name, Callable callable) {
+    super(position);
+    this.name = name;
+    this.callable = callable;
+  }
+
+  public static FunctionStatement parseFunctionStatement (Tokens tokens) {
+    Position position = tokens.require(TokenType.T_KEYWORD_FUNCTION).getPosition();
+
+    Identifier name = Identifier.requireIdentifier(tokens);
+
+    Callable callable = Callable.parseCallable(tokens, TokenType.T_COLON, false);
+
+    return new FunctionStatement(position, name, callable);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/InterfaceStatement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/InterfaceStatement.java
new file mode 100644
index 0000000000..64445b7b52
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/InterfaceStatement.java
@@ -0,0 +1,21 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Interface.Interface;
+
+public class InterfaceStatement extends Statement {
+  private final Interface intface;
+
+  private InterfaceStatement (Interface intface) {
+    super(intface.getPosition());
+    this.intface = intface;
+  }
+
+  public static InterfaceStatement parseInterfaceStatement (Tokens tokens) {
+    return new InterfaceStatement(Interface.parseInterface(tokens));
+  }
+
+  public Interface getInterface () {
+    return intface;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/Statement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/Statement.java
new file mode 100644
index 0000000000..7e87ecd7b3
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/Statement.java
@@ -0,0 +1,15 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public abstract class Statement {
+  private final Position position;
+
+  protected Statement (Position position) {
+    this.position = position;
+  }
+
+  public Position getPosition () {
+    return position;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/VariableStatement.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/VariableStatement.java
new file mode 100644
index 0000000000..5c5153e794
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Statement/VariableStatement.java
@@ -0,0 +1,47 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Statement;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Token;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+public class VariableStatement extends Statement implements DeclarableStatement {
+  private final Identifier name;
+  private final Type type;
+  private final boolean isReadOnly;
+
+  private VariableStatement (Position position, Identifier name, Type type, boolean isReadOnly) {
+    super(position);
+    this.name = name;
+    this.type = type;
+    this.isReadOnly = isReadOnly;
+  }
+
+  public static VariableStatement parseVariableStatement(Tokens tokens) {
+    Token t = tokens.accept();
+    Position position = t.getPosition();
+
+    boolean isReadOnly;
+
+    switch (t.getType()) {
+    case T_KEYWORD_VAR:
+      isReadOnly = false;
+      break;
+
+    case T_KEYWORD_CONST:
+      isReadOnly = true;
+      break;
+
+    default:
+      throw tokens.constructRequiredSyntaxNotFoundException("Expected variable or constant declaration");
+    }
+
+    Identifier name = Identifier.requireIdentifier(tokens);
+    tokens.require(TokenType.T_COLON);
+    Type type = Type.parseType(tokens);
+
+    return new VariableStatement(position, name, type, isReadOnly);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/CallableSubtype.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/CallableSubtype.java
new file mode 100644
index 0000000000..d8aff33bbf
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/CallableSubtype.java
@@ -0,0 +1,28 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Callable;
+
+public class CallableSubtype extends Subtype {
+  private final Callable callable;
+
+  public CallableSubtype (Callable callable) {
+    this.callable = callable;
+  }
+
+  public static CallableSubtype parseCallableSubtype (Tokens tokens) {
+    boolean wrapped = tokens.peekType(2) == TokenType.T_LEFT_PARENTHESIS;
+    if (wrapped) {
+      tokens.require(TokenType.T_LEFT_PARENTHESIS);
+    }
+
+    Callable callable = Callable.parseCallable(tokens, TokenType.T_EQUALS_AND_RIGHT_CHEVRON, false);
+
+    if (wrapped) {
+      tokens.require(TokenType.T_RIGHT_PARENTHESIS);
+    }
+
+    return new CallableSubtype(callable);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/PrimitiveSubtype.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/PrimitiveSubtype.java
new file mode 100644
index 0000000000..f9b4f714ef
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/PrimitiveSubtype.java
@@ -0,0 +1,43 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.Type.PrimitiveSubtype.Primitive.STRING_TO_PRIMITIVE_MAP;
+
+public class PrimitiveSubtype extends Subtype {
+  private final Primitive type;
+
+  private PrimitiveSubtype (Primitive type) {
+    this.type = type;
+  }
+
+  public static PrimitiveSubtype parsePrimitiveSubtype (Tokens tokens) {
+    Identifier identifier = Identifier.requireIdentifier(tokens);
+    String name = identifier.getName();
+    if (!STRING_TO_PRIMITIVE_MAP.containsKey(name)) {
+      throw tokens.constructRequiredSyntaxNotFoundException("Required a primitive subtype");
+    }
+    return new PrimitiveSubtype(STRING_TO_PRIMITIVE_MAP.get(name));
+  }
+
+  public enum Primitive {
+    NUMBER, NULL, BOOLEAN, STRING;
+
+    public static final Map<String, Primitive> STRING_TO_PRIMITIVE_MAP = _createStringToPrimitiveMap();
+
+    private static Map<String, Primitive> _createStringToPrimitiveMap () {
+      Map<String, Primitive> stringPrimitiveMap = new HashMap<>();
+
+      stringPrimitiveMap.put("boolean", BOOLEAN);
+      stringPrimitiveMap.put("null", NULL);
+      stringPrimitiveMap.put("number", NUMBER);
+      stringPrimitiveMap.put("string", STRING);
+
+      return stringPrimitiveMap;
+    }
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/ReferenceSubtype.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/ReferenceSubtype.java
new file mode 100644
index 0000000000..218b6cb5d0
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/ReferenceSubtype.java
@@ -0,0 +1,28 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Syntax.Identifier;
+
+public class ReferenceSubtype extends Subtype {
+  private final Identifier name;
+  private final Identifier lookupTerm; // Can be null
+
+  private ReferenceSubtype (Identifier name, Identifier lookupTerm) {
+    this.name = name;
+    this.lookupTerm = lookupTerm;
+  }
+
+  public static ReferenceSubtype parseReferenceSubtype (Tokens tokens) {
+    Identifier identifier = Identifier.requireIdentifier(tokens);
+    Identifier lookupTerm = null;
+
+    if (tokens.peekType() == TokenType.T_LEFT_SQUARE_BRACKET && tokens.peekType(2) == TokenType.T_IDENTIFIER) {
+      tokens.skip();
+      lookupTerm = Identifier.requireIdentifier(tokens);
+      tokens.require(TokenType.T_RIGHT_SQUARE_BRACKET);
+    }
+
+    return new ReferenceSubtype(identifier, lookupTerm);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/StringLiteralSubtype.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/StringLiteralSubtype.java
new file mode 100644
index 0000000000..36dd6b79b5
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/StringLiteralSubtype.java
@@ -0,0 +1,16 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+
+public class StringLiteralSubtype extends Subtype {
+  private final String value;
+
+  private StringLiteralSubtype (String value) {
+    this.value = value;
+  }
+
+  public static StringLiteralSubtype parseStringSubtype (Tokens tokens) {
+    return new StringLiteralSubtype(tokens.require(TokenType.T_LITERAL_STRING).getValue());
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Subtype.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Subtype.java
new file mode 100644
index 0000000000..94cab98b10
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Subtype.java
@@ -0,0 +1,47 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Exception.InternalStateError;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+
+import static org.ooml.oomlc.core.env.gen.Parse.Syntax.Type.PrimitiveSubtype.Primitive.STRING_TO_PRIMITIVE_MAP;
+
+public abstract class Subtype {
+  private boolean isArray;
+
+  public static Subtype parseSubtype (Tokens tokens) {
+    Subtype subtype;
+    boolean isArray = false;
+
+    switch (tokens.peekType()) {
+    case T_IDENTIFIER:
+      String identifierName = tokens.peek().getValue();
+      if (STRING_TO_PRIMITIVE_MAP.containsKey(identifierName)) {
+        subtype = PrimitiveSubtype.parsePrimitiveSubtype(tokens);
+      } else {
+        subtype = ReferenceSubtype.parseReferenceSubtype(tokens);
+      }
+      break;
+
+    case T_LEFT_PARENTHESIS:
+      subtype = CallableSubtype.parseCallableSubtype(tokens);
+      break;
+
+    case T_LITERAL_STRING:
+      subtype = StringLiteralSubtype.parseStringSubtype(tokens);
+      break;
+
+    default:
+      throw new InternalStateError("Invalid subtype token");
+    }
+
+    if (tokens.skipIfNext(TokenType.T_LEFT_SQUARE_BRACKET)) {
+      tokens.require(TokenType.T_RIGHT_SQUARE_BRACKET);
+      isArray = true;
+    }
+
+    subtype.isArray = isArray;
+
+    return subtype;
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Type.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Type.java
new file mode 100644
index 0000000000..ba95d2ec04
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Syntax/Type/Type.java
@@ -0,0 +1,30 @@
+package org.ooml.oomlc.core.env.gen.Parse.Syntax.Type;
+
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.TokenType;
+import org.ooml.oomlc.core.env.gen.Parse.Parsing.Tokens;
+import org.ooml.oomlc.core.env.gen.Parse.Utils.Position;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Type {
+  private final List<Subtype> subtypes;
+  private final Position position;
+
+  private Type (Position position, List<Subtype> subtypes) {
+    this.position = position;
+    this.subtypes = subtypes;
+  }
+
+  public static Type parseType (Tokens tokens) {
+    Position position = tokens.peek().getPosition();
+    List<Subtype> subtypes = new ArrayList<>();
+
+    do {
+      subtypes.add(Subtype.parseSubtype(tokens));
+    } while (tokens.skipIfNext(TokenType.T_PIPE));
+
+    return new Type(position, subtypes);
+  }
+
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Acceptable.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Acceptable.java
new file mode 100644
index 0000000000..05020228ae
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Acceptable.java
@@ -0,0 +1,18 @@
+package org.ooml.oomlc.core.env.gen.Parse.Utils;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+public class Acceptable<T> {
+  private final Set<T> set;
+
+  @SafeVarargs
+  public Acceptable (T... t) {
+    set = new HashSet<>(Arrays.asList(t));
+  }
+
+  public boolean has (T t) {
+    return set.contains(t);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Matchable.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Matchable.java
new file mode 100755
index 0000000000..f4c8aca887
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Matchable.java
@@ -0,0 +1,7 @@
+package org.ooml.oomlc.core.env.gen.Parse.Utils;
+
+public interface Matchable<M> {
+  M matcherConsume ();
+
+  void matcherReverse ();
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/MatcherTreeNode.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/MatcherTreeNode.java
new file mode 100755
index 0000000000..d18669bd1e
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/MatcherTreeNode.java
@@ -0,0 +1,53 @@
+package org.ooml.oomlc.core.env.gen.Parse.Utils;
+
+import org.ooml.oomlc.core.env.gen.Parse.Exception.InternalStateError;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+public class MatcherTreeNode<M, R> {
+  protected final Map<M, MatcherTreeNode<M, R>> children = new TreeMap<>();
+  protected R tail = null;
+
+  public boolean hasTail () {
+    return tail != null;
+  }
+
+  public void addSequence (M[] sequence, int start, R result) {
+    M m = sequence[start];
+    MatcherTreeNode<M, R> child = children.get(m);
+
+    if (child == null) {
+      child = new MatcherTreeNode<>();
+      children.put(m, child);
+    }
+
+    if (start == sequence.length - 1) {
+      if (child.hasTail()) {
+        throw new InternalStateError("Duplicate matcher sequence");
+      }
+      child.tail = result;
+    } else {
+      child.addSequence(sequence, start + 1, result);
+    }
+  }
+
+  @SafeVarargs
+  public final void addSequence (R result, M... sequence) {
+    addSequence(sequence, 0, result);
+  }
+
+  public R match (Matchable<M> toMatch) {
+    M currentUnit = toMatch.matcherConsume();
+    MatcherTreeNode<M, R> child = children.get(currentUnit);
+    if (child == null) {
+      toMatch.matcherReverse();
+      return tail;
+    }
+    return child.match(toMatch);
+  }
+
+  public boolean hasChild (M unit) {
+    return children.containsKey(unit);
+  }
+}
diff --git a/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Position.java b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Position.java
new file mode 100644
index 0000000000..fc8092921a
--- /dev/null
+++ b/gen/main/java/org/ooml/oomlc/core/env/gen/Parse/Utils/Position.java
@@ -0,0 +1,19 @@
+package org.ooml.oomlc.core.env.gen.Parse.Utils;
+
+public class Position {
+  private final int line;
+  private final int column;
+
+  public Position (int line, int column) {
+    this.line = line;
+    this.column = column;
+  }
+
+  public int getLine () {
+    return line;
+  }
+
+  public int getColumn () {
+    return column;
+  }
+}
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000000..5554403509
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.ooml.oomlc.core.env.gen</groupId>
+  <artifactId>oomlc-core-env-gen</artifactId>
+  <version>20180431-SNAPSHOT</version>
+
+  <properties>
+    <maven.compiler.source>1.8</maven.compiler.source>
+    <maven.compiler.target>1.8</maven.compiler.target>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.2</version>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <archive>
+            <manifest>
+              <mainClass>org.ooml.oomlc.core.env.gen.Main</mainClass>
+            </manifest>
+          </archive>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <appendAssemblyId>false</appendAssemblyId>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
